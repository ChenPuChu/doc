### 算法步骤
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个；
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
3. 针对所有的元素重复以上的步骤，除了最后已排序的部分，因为该部分已经处于稳定位置；
4. 重复步骤1~3，直到没有再需要交换。
### C语言实现
以下是冒泡排序的C语言版本：
```c
#include <stdio.h>
void bubbleSort(int array[], int n) {
    for (int i = 0; i < n-1; i++) {     //外层循环控制比较次数，直到没有交换为止。
        for (int j = 0; j <n -i -1 ;j++){   //内层循环实际进行元素的交换。
            if(array[j]>array[j+1]) {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;     //如果左边的大于右边，则交换两个元素的位置。
            }       
        }   
    }   
}   //冒泡排序函数主体。通过n-i-1是因为每一轮循环结束后,最大的数字已经位于数组的末尾了,所以在内层循环中不必再进行比较。 
int main() {
    int array[] = {64,34,25,12,22,11};  //要排序的数组。
    bubbleSort(array, sizeof(array)/sizeof(int));   //传递数组的指针和其长度。
    
    for (int i=0; i<6; ++i) {   //打印结果。
        printf("%d ", array[i]); 
    }
    return 0;
}  //主函数中输出排序后的数组。注意：C语言没有内置的打印多元素功能，所以使用循环来手动进行。
```